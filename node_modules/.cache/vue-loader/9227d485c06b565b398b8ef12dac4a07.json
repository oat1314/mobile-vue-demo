{"remainingRequest":"F:\\BaiduNetdiskDownload\\思否\\20年spring boot+vue课程源码\\课程源码\\00-前端-后端代码-数据库\\xdclass_front\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!F:\\BaiduNetdiskDownload\\思否\\20年spring boot+vue课程源码\\课程源码\\00-前端-后端代码-数据库\\xdclass_front\\node_modules\\cube-ui\\src\\components\\sticky\\sticky.vue?vue&type=script&lang=js&","dependencies":[{"path":"F:\\BaiduNetdiskDownload\\思否\\20年spring boot+vue课程源码\\课程源码\\00-前端-后端代码-数据库\\xdclass_front\\node_modules\\cube-ui\\src\\components\\sticky\\sticky.vue","mtime":499162500000},{"path":"F:\\BaiduNetdiskDownload\\思否\\20年spring boot+vue课程源码\\课程源码\\00-前端-后端代码-数据库\\xdclass_front\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"F:\\BaiduNetdiskDownload\\思否\\20年spring boot+vue课程源码\\课程源码\\00-前端-后端代码-数据库\\xdclass_front\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"F:\\BaiduNetdiskDownload\\思否\\20年spring boot+vue课程源码\\课程源码\\00-前端-后端代码-数据库\\xdclass_front\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"F:\\BaiduNetdiskDownload\\思否\\20年spring boot+vue课程源码\\课程源码\\00-前端-后端代码-数据库\\xdclass_front\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCB7CiAgZ2V0UmVjdCwKICBwcmVmaXhTdHlsZQp9IGZyb20gJy4uLy4uL2NvbW1vbi9oZWxwZXJzL2RvbScKCmNvbnN0IENPTVBPTkVOVF9OQU1FID0gJ2N1YmUtc3RpY2t5Jwpjb25zdCBFVkVOVF9DSEFOR0UgPSAnY2hhbmdlJwpjb25zdCBFVkVOVF9ESUZGX0NIQU5HRSA9ICdkaWZmLWNoYW5nZScKCmNvbnN0IHRyYW5zZm9ybVN0eWxlS2V5ID0gcHJlZml4U3R5bGUoJ3RyYW5zZm9ybScpCgpleHBvcnQgZGVmYXVsdCB7CiAgbmFtZTogQ09NUE9ORU5UX05BTUUsCiAgcHJvdmlkZSgpIHsKICAgIHJldHVybiB7CiAgICAgIHN0aWNreTogdGhpcwogICAgfQogIH0sCiAgcHJvcHM6IHsKICAgIHBvczogewogICAgICB0eXBlOiBOdW1iZXIsCiAgICAgIHJlcXVpcmVkOiB0cnVlCiAgICB9LAogICAgY2hlY2tUb3A6IHsKICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgZGVmYXVsdDogdHJ1ZQogICAgfSwKICAgIGZpeGVkU2hvd0FuaTogewogICAgICB0eXBlOiBTdHJpbmcsCiAgICAgIGRlZmF1bHQoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tUb3AgPyAnJyA6ICdjdWJlLXN0aWNreS1maXhlZC1mYWRlJwogICAgICB9CiAgICB9LAogICAgb2Zmc2V0OiB7CiAgICAgIHR5cGU6IE51bWJlciwKICAgICAgZGVmYXVsdDogMAogICAgfQogIH0sCiAgZGF0YSgpIHsKICAgIHJldHVybiB7CiAgICAgIGRpZmY6IDAsCiAgICAgIGN1cnJlbnREaWZmOiAwLAogICAgICBjdXJyZW50SW5kZXg6IC0xLAogICAgICBjdXJyZW50S2V5OiAnJwogICAgfQogIH0sCiAgY29tcHV0ZWQ6IHsKICAgIGZpeGVkU2hvdygpIHsKICAgICAgY29uc3QgdGFyZ2V0RWxlID0gdGhpcy5lbGVzW3RoaXMuY3VycmVudEluZGV4XQogICAgICByZXR1cm4gISF0YXJnZXRFbGUKICAgIH0KICB9LAogIHdhdGNoOiB7CiAgICBkaWZmKG5ld1ZhbCkgewogICAgICBpZiAobmV3VmFsID49IDApIHsKICAgICAgICBuZXdWYWwgPSAwCiAgICAgIH0KICAgICAgbmV3VmFsID0gTWF0aC5jZWlsKG5ld1ZhbCkKICAgICAgaWYgKHRoaXMuX2ZpeGVkVG9wID09PSBuZXdWYWwpIHsKICAgICAgICByZXR1cm4KICAgICAgfQogICAgICB0aGlzLl9maXhlZFRvcCA9IG5ld1ZhbAogICAgICB0aGlzLiRyZWZzLmZpeGVkRWxlLnN0eWxlW3RyYW5zZm9ybVN0eWxlS2V5XSA9IGB0cmFuc2xhdGUzZCgwLCAke25ld1ZhbH1weCwgMClgCiAgICB9LAogICAgcG9zOiAnY29tcHV0ZUN1cnJlbnRTdGlja3knLAogICAgY3VycmVudEluZGV4KG5ld0luZGV4LCBvbGRJbmRleCkgewogICAgICBjb25zdCBvbGRFbGUgPSB0aGlzLmVsZXNbb2xkSW5kZXhdCiAgICAgIGNvbnN0IG5ld0VsZSA9IHRoaXMuZWxlc1tuZXdJbmRleF0KCiAgICAgIGNvbnN0IGN1cnJlbnRLZXkgPSAobmV3RWxlICYmIG5ld0VsZS5lbGVLZXkgIT09IHVuZGVmaW5lZCkgPyBuZXdFbGUuZWxlS2V5IDogbmV3SW5kZXggPT09IC0xID8gJycgOiBuZXdJbmRleAogICAgICBjb25zdCBmaXhlZEVsZSA9IHRoaXMuJHJlZnMuZml4ZWRFbGUKICAgICAgY29uc3QgZml4ZWRTbG90ID0gdGhpcy4kc2xvdHMuZml4ZWQgfHwgdGhpcy4kc2NvcGVkU2xvdHMuZml4ZWQKCiAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsKICAgICAgICBpZiAoZml4ZWRTbG90KSB7CiAgICAgICAgICB0aGlzLmZpeGVkRWxlSGVpZ2h0ID0gZml4ZWRFbGUub2Zmc2V0SGVpZ2h0CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGNvbnN0IG9sZENoaWxkID0gZml4ZWRFbGUuZmlyc3RFbGVtZW50Q2hpbGQKICAgICAgICAgIGlmIChvbGRFbGUpIHsKICAgICAgICAgICAgb2xkRWxlLiRlbC5hcHBlbmRDaGlsZChvbGRDaGlsZCkKICAgICAgICAgICAgb2xkRWxlLnJlZnJlc2goKQogICAgICAgICAgfQogICAgICAgICAgaWYgKG5ld0VsZSkgewogICAgICAgICAgICBmaXhlZEVsZS5hcHBlbmRDaGlsZChuZXdFbGUuJGVsLmZpcnN0RWxlbWVudENoaWxkKQogICAgICAgICAgICB0aGlzLmZpeGVkRWxlSGVpZ2h0ID0gZml4ZWRFbGUub2Zmc2V0SGVpZ2h0CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aGlzLmZpeGVkRWxlSGVpZ2h0ID0gMAogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSkKCiAgICAgIHRoaXMuY3VycmVudEtleSA9IGN1cnJlbnRLZXkKICAgICAgdGhpcy4kZW1pdChFVkVOVF9DSEFOR0UsIGN1cnJlbnRLZXksIG5ld0luZGV4KQogICAgfSwKICAgIGN1cnJlbnREaWZmKG5ld1ZhbCkgewogICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodHNbdGhpcy5jdXJyZW50SW5kZXhdIHx8IDAKICAgICAgdGhpcy4kZW1pdChFVkVOVF9ESUZGX0NIQU5HRSwgbmV3VmFsLCBoZWlnaHQpCiAgICB9CiAgfSwKICBjcmVhdGVkKCkgewogICAgdGhpcy5maXhlZEVsZUhlaWdodCA9IDAKICAgIHRoaXMuZWxlcyA9IFtdCiAgICB0aGlzLnBvc2l0aW9ucyA9IFtdCiAgICB0aGlzLmhlaWdodHMgPSBbXQogIH0sCiAgbW91bnRlZCgpIHsKICAgIHRoaXMucmVmcmVzaCgpCiAgfSwKICBtZXRob2RzOiB7CiAgICBhZGRFbGUoZWxlKSB7CiAgICAgIHRoaXMuZWxlcy5wdXNoKGVsZSkKICAgIH0sCiAgICByZW1vdmVFbGUoZWxlKSB7CiAgICAgIGNvbnN0IGkgPSB0aGlzLmVsZXMuaW5kZXhPZihlbGUpCiAgICAgIHRoaXMuZWxlcy5zcGxpY2UoaSwgMSkKICAgICAgdGhpcy5wb3NpdGlvbnMuc3BsaWNlKGksIDEpCiAgICB9LAogICAgcmVmcmVzaCgpIHsKICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4gewogICAgICAgIHRoaXMuZWxlcy5mb3JFYWNoKChlbGUpID0+IHsKICAgICAgICAgIGVsZS5yZWZyZXNoKCkKICAgICAgICB9KQogICAgICAgIHRoaXMuX2NhbGN1bGF0ZUhlaWdodCgpCiAgICAgICAgdGhpcy5jb21wdXRlQ3VycmVudFN0aWNreSh0aGlzLnBvcykKICAgICAgfSkKICAgIH0sCiAgICBjb21wdXRlQ3VycmVudFN0aWNreShzY3JvbGxZKSB7CiAgICAgIHNjcm9sbFkgKz0gdGhpcy5vZmZzZXQKCiAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IHRoaXMucG9zaXRpb25zCiAgICAgIGNvbnN0IGhlaWdodHMgPSB0aGlzLmhlaWdodHMKICAgICAgY29uc3QgY2hlY2tUb3AgPSB0aGlzLmNoZWNrVG9wCgogICAgICBjb25zdCBsZW4gPSBwb3NpdGlvbnMubGVuZ3RoCiAgICAgIGZvciAobGV0IGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkgewogICAgICAgIGNvbnN0IGlzTGFzdCA9IGkgPT09IGxlbiAtIDEKICAgICAgICBjb25zdCBuZXh0VG9wID0gaXNMYXN0ID8gc2Nyb2xsWSA6IHBvc2l0aW9uc1tpICsgMV0KICAgICAgICBsZXQgdG9wCiAgICAgICAgbGV0IGJvdHRvbQogICAgICAgIGlmIChjaGVja1RvcCkgewogICAgICAgICAgdG9wID0gcG9zaXRpb25zW2ldCiAgICAgICAgICBib3R0b20gPSB0b3AgKyBoZWlnaHRzW2ldCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRvcCA9IHBvc2l0aW9uc1tpXSArIGhlaWdodHNbaV0KICAgICAgICAgIGJvdHRvbSA9IHRvcAogICAgICAgIH0KICAgICAgICBjb25zdCBtYXggPSBNYXRoLm1heChib3R0b20sIG5leHRUb3ApCgogICAgICAgIGlmIChzY3JvbGxZID49IHRvcCAmJiBzY3JvbGxZIDw9IG1heCkgewogICAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSBpCiAgICAgICAgICB0aGlzLmN1cnJlbnREaWZmID0gc2Nyb2xsWSAtIHRvcAogICAgICAgICAgY29uc3QgZGlmZiA9IG5leHRUb3AgLSBzY3JvbGxZCiAgICAgICAgICBpZiAoZGlmZiA+PSAwICYmICFpc0xhc3QpIHsKICAgICAgICAgICAgdGhpcy5kaWZmID0gZGlmZiAtICh0aGlzLmZpeGVkRWxlSGVpZ2h0IHx8IGhlaWdodHNbaV0pCiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aGlzLmRpZmYgPSAwCiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4KICAgICAgICB9CiAgICAgIH0KICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSAtMQogICAgICB0aGlzLmN1cnJlbnREaWZmID0gMAogICAgfSwKICAgIF9jYWxjdWxhdGVIZWlnaHQoKSB7CiAgICAgIGNvbnN0IGVsZXMgPSB0aGlzLmVsZXMKICAgICAgZWxlcy5mb3JFYWNoKChlbGUsIGkpID0+IHsKICAgICAgICBjb25zdCB7IHRvcCwgaGVpZ2h0IH0gPSBnZXRSZWN0KGVsZS4kZWwpCiAgICAgICAgdGhpcy5wb3NpdGlvbnNbaV0gPSB0b3AKICAgICAgICB0aGlzLmhlaWdodHNbaV0gPSBoZWlnaHQKICAgICAgfSkKICAgICAgdGhpcy5maXhlZEVsZUhlaWdodCA9IHRoaXMuJHJlZnMuZml4ZWRFbGUub2Zmc2V0SGVpZ2h0CiAgICB9CiAgfQp9Cg=="},{"version":3,"sources":["sticky.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;AAeA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"sticky.vue","sourceRoot":"node_modules/cube-ui/src/components/sticky","sourcesContent":["<template>\n  <div class=\"cube-sticky\">\n    <slot></slot>\n    <transition :name=\"fixedShowAni\">\n      <div\n        ref=\"fixedEle\"\n        v-show=\"fixedShow\"\n        class=\"cube-sticky-fixed\">\n        <slot name=\"fixed\" :current=\"currentKey\" :index=\"currentIndex\"></slot>\n      </div>\n    </transition>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\n  import {\n    getRect,\n    prefixStyle\n  } from '../../common/helpers/dom'\n\n  const COMPONENT_NAME = 'cube-sticky'\n  const EVENT_CHANGE = 'change'\n  const EVENT_DIFF_CHANGE = 'diff-change'\n\n  const transformStyleKey = prefixStyle('transform')\n\n  export default {\n    name: COMPONENT_NAME,\n    provide() {\n      return {\n        sticky: this\n      }\n    },\n    props: {\n      pos: {\n        type: Number,\n        required: true\n      },\n      checkTop: {\n        type: Boolean,\n        default: true\n      },\n      fixedShowAni: {\n        type: String,\n        default() {\n          return this.checkTop ? '' : 'cube-sticky-fixed-fade'\n        }\n      },\n      offset: {\n        type: Number,\n        default: 0\n      }\n    },\n    data() {\n      return {\n        diff: 0,\n        currentDiff: 0,\n        currentIndex: -1,\n        currentKey: ''\n      }\n    },\n    computed: {\n      fixedShow() {\n        const targetEle = this.eles[this.currentIndex]\n        return !!targetEle\n      }\n    },\n    watch: {\n      diff(newVal) {\n        if (newVal >= 0) {\n          newVal = 0\n        }\n        newVal = Math.ceil(newVal)\n        if (this._fixedTop === newVal) {\n          return\n        }\n        this._fixedTop = newVal\n        this.$refs.fixedEle.style[transformStyleKey] = `translate3d(0, ${newVal}px, 0)`\n      },\n      pos: 'computeCurrentSticky',\n      currentIndex(newIndex, oldIndex) {\n        const oldEle = this.eles[oldIndex]\n        const newEle = this.eles[newIndex]\n\n        const currentKey = (newEle && newEle.eleKey !== undefined) ? newEle.eleKey : newIndex === -1 ? '' : newIndex\n        const fixedEle = this.$refs.fixedEle\n        const fixedSlot = this.$slots.fixed || this.$scopedSlots.fixed\n\n        this.$nextTick(() => {\n          if (fixedSlot) {\n            this.fixedEleHeight = fixedEle.offsetHeight\n          } else {\n            const oldChild = fixedEle.firstElementChild\n            if (oldEle) {\n              oldEle.$el.appendChild(oldChild)\n              oldEle.refresh()\n            }\n            if (newEle) {\n              fixedEle.appendChild(newEle.$el.firstElementChild)\n              this.fixedEleHeight = fixedEle.offsetHeight\n            } else {\n              this.fixedEleHeight = 0\n            }\n          }\n        })\n\n        this.currentKey = currentKey\n        this.$emit(EVENT_CHANGE, currentKey, newIndex)\n      },\n      currentDiff(newVal) {\n        const height = this.heights[this.currentIndex] || 0\n        this.$emit(EVENT_DIFF_CHANGE, newVal, height)\n      }\n    },\n    created() {\n      this.fixedEleHeight = 0\n      this.eles = []\n      this.positions = []\n      this.heights = []\n    },\n    mounted() {\n      this.refresh()\n    },\n    methods: {\n      addEle(ele) {\n        this.eles.push(ele)\n      },\n      removeEle(ele) {\n        const i = this.eles.indexOf(ele)\n        this.eles.splice(i, 1)\n        this.positions.splice(i, 1)\n      },\n      refresh() {\n        this.$nextTick(() => {\n          this.eles.forEach((ele) => {\n            ele.refresh()\n          })\n          this._calculateHeight()\n          this.computeCurrentSticky(this.pos)\n        })\n      },\n      computeCurrentSticky(scrollY) {\n        scrollY += this.offset\n\n        const positions = this.positions\n        const heights = this.heights\n        const checkTop = this.checkTop\n\n        const len = positions.length\n        for (let i = len - 1; i >= 0; i--) {\n          const isLast = i === len - 1\n          const nextTop = isLast ? scrollY : positions[i + 1]\n          let top\n          let bottom\n          if (checkTop) {\n            top = positions[i]\n            bottom = top + heights[i]\n          } else {\n            top = positions[i] + heights[i]\n            bottom = top\n          }\n          const max = Math.max(bottom, nextTop)\n\n          if (scrollY >= top && scrollY <= max) {\n            this.currentIndex = i\n            this.currentDiff = scrollY - top\n            const diff = nextTop - scrollY\n            if (diff >= 0 && !isLast) {\n              this.diff = diff - (this.fixedEleHeight || heights[i])\n            } else {\n              this.diff = 0\n            }\n            return\n          }\n        }\n        this.currentIndex = -1\n        this.currentDiff = 0\n      },\n      _calculateHeight() {\n        const eles = this.eles\n        eles.forEach((ele, i) => {\n          const { top, height } = getRect(ele.$el)\n          this.positions[i] = top\n          this.heights[i] = height\n        })\n        this.fixedEleHeight = this.$refs.fixedEle.offsetHeight\n      }\n    }\n  }\n</script>\n\n<style lang=\"stylus\" rel=\"stylesheet/stylus\">\n  .cube-sticky\n    position: relative\n    height: 100%\n    overflow: hidden\n  .cube-sticky-fixed\n    z-index: 1\n    position: absolute\n    top: 0\n    left: 0\n    right: 0\n  .cube-sticky-fixed-fade-enter, .cube-sticky-fixed-fade-leave-active\n    opacity: 0\n  .cube-sticky-fixed-fade-enter-active, .cube-sticky-fixed-fade-leave-active\n    transition: all .2s ease-in-out\n</style>\n"]}]}