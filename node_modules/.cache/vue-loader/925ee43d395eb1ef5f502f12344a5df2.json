{"remainingRequest":"F:\\BaiduNetdiskDownload\\思否\\20年spring boot+vue课程源码\\课程源码\\00-前端-后端代码-数据库\\xdclass_front\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!F:\\BaiduNetdiskDownload\\思否\\20年spring boot+vue课程源码\\课程源码\\00-前端-后端代码-数据库\\xdclass_front\\node_modules\\cube-ui\\src\\components\\swipe\\swipe-item.vue?vue&type=script&lang=js&","dependencies":[{"path":"F:\\BaiduNetdiskDownload\\思否\\20年spring boot+vue课程源码\\课程源码\\00-前端-后端代码-数据库\\xdclass_front\\node_modules\\cube-ui\\src\\components\\swipe\\swipe-item.vue","mtime":499162500000},{"path":"F:\\BaiduNetdiskDownload\\思否\\20年spring boot+vue课程源码\\课程源码\\00-前端-后端代码-数据库\\xdclass_front\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"F:\\BaiduNetdiskDownload\\思否\\20年spring boot+vue课程源码\\课程源码\\00-前端-后端代码-数据库\\xdclass_front\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"F:\\BaiduNetdiskDownload\\思否\\20年spring boot+vue课程源码\\课程源码\\00-前端-后端代码-数据库\\xdclass_front\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"F:\\BaiduNetdiskDownload\\思否\\20年spring boot+vue课程源码\\课程源码\\00-前端-后端代码-数据库\\xdclass_front\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCB7CiAgZ2V0UmVjdCwKICBwcmVmaXhTdHlsZQp9IGZyb20gJy4uLy4uL2NvbW1vbi9oZWxwZXJzL2RvbScKCmltcG9ydCB7IGVhc2VPdXRRdWFydCwgZWFzZU91dEN1YmljIH0gZnJvbSAnLi4vLi4vY29tbW9uL2hlbHBlcnMvZWFzZScKaW1wb3J0IHsgZ2V0Tm93IH0gZnJvbSAnLi4vLi4vY29tbW9uL2xhbmcvZGF0ZScKCmNvbnN0IENPTVBPTkVOVF9OQU1FID0gJ2N1YmUtc3dpcGUtaXRlbScKY29uc3QgRVZFTlRfSVRFTV9DTElDSyA9ICdpdGVtLWNsaWNrJwpjb25zdCBFVkVOVF9CVE5fQ0xJQ0sgPSAnYnRuLWNsaWNrJwpjb25zdCBFVkVOVF9TQ1JPTEwgPSAnc2Nyb2xsJwpjb25zdCBFVkVOVF9BQ1RJVkUgPSAnYWN0aXZlJwpjb25zdCBESVJFQ1RJT05fTEVGVCA9IDEKY29uc3QgRElSRUNUSU9OX1JJR0hUID0gLTEKY29uc3QgU1RBVEVfU0hSSU5LID0gMApjb25zdCBTVEFURV9HUk9XID0gMQpjb25zdCBlYXNpbmdUaW1lID0gNjAwCmNvbnN0IG1vbWVudHVtTGltaXRUaW1lID0gMzAwCmNvbnN0IG1vbWVudHVtTGltaXREaXN0YW5jZSA9IDE1CmNvbnN0IGRpcmVjdGlvbkxvY2tUaHJlc2hvbGQgPSA1Cgpjb25zdCB0cmFuc2Zvcm0gPSBwcmVmaXhTdHlsZSgndHJhbnNmb3JtJykKY29uc3QgdHJhbnNpdGlvblByb3BlcnR5ID0gcHJlZml4U3R5bGUoJ3RyYW5zaXRpb25Qcm9wZXJ0eScpCmNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbiA9IHByZWZpeFN0eWxlKCd0cmFuc2l0aW9uRHVyYXRpb24nKQpjb25zdCB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24gPSBwcmVmaXhTdHlsZSgndHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uJykKCmV4cG9ydCBkZWZhdWx0IHsKICBuYW1lOiBDT01QT05FTlRfTkFNRSwKICBpbmplY3Q6IFsnc3dpcGUnXSwKICBwcm9wczogewogICAgaXRlbTogewogICAgICB0eXBlOiBPYmplY3QsCiAgICAgIGRlZmF1bHQoKSB7CiAgICAgICAgcmV0dXJuIHt9CiAgICAgIH0KICAgIH0sCiAgICBidG5zOiB7CiAgICAgIHR5cGU6IEFycmF5LAogICAgICBkZWZhdWx0KCkgewogICAgICAgIHJldHVybiBbXQogICAgICB9CiAgICB9LAogICAgaW5kZXg6IHsKICAgICAgdHlwZTogTnVtYmVyLAogICAgICBpbmRleDogLTEKICAgIH0sCiAgICBhdXRvU2hyaW5rOiB7CiAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgIGRlZmF1bHQ6IGZhbHNlCiAgICB9CiAgfSwKICB3YXRjaDogewogICAgYnRucygpIHsKICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4gewogICAgICAgIHRoaXMucmVmcmVzaCgpCiAgICAgIH0pCiAgICB9CiAgfSwKICBjcmVhdGVkKCkgewogICAgdGhpcy54ID0gMAogICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1NIUklOSwogICAgdGhpcy5zd2lwZS5hZGRJdGVtKHRoaXMpCiAgfSwKICBtb3VudGVkKCkgewogICAgdGhpcy5zY3JvbGxlclN0eWxlID0gdGhpcy4kcmVmcy5zd2lwZUl0ZW0uc3R5bGUKICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsKICAgICAgdGhpcy5yZWZyZXNoKCkKICAgIH0pCiAgICB0aGlzLiRvbihFVkVOVF9TQ1JPTEwsIHRoaXMuX2hhbmRsZUJ0bnMpCiAgfSwKICBtZXRob2RzOiB7CiAgICBfaW5pdENhY2hlZEJ0bnMoKSB7CiAgICAgIHRoaXMuY2FjaGVkQnRucyA9IFtdCiAgICAgIGNvbnN0IGxlbiA9IHRoaXMuJHJlZnMuYnRucy5sZW5ndGgKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykgewogICAgICAgIHRoaXMuY2FjaGVkQnRucy5wdXNoKHsKICAgICAgICAgIHdpZHRoOiBnZXRSZWN0KHRoaXMuJHJlZnMuYnRuc1tpXSkud2lkdGgKICAgICAgICB9KQogICAgICB9CiAgICB9LAogICAgX2hhbmRsZUJ0bnMoeCkgewogICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8KICAgICAgaWYgKHRoaXMuYnRucy5sZW5ndGggPT09IDApIHsKICAgICAgICByZXR1cm4KICAgICAgfQogICAgICBjb25zdCBsZW4gPSB0aGlzLiRyZWZzLmJ0bnMubGVuZ3RoCiAgICAgIGxldCBkZWx0YSA9IDAKICAgICAgbGV0IHRvdGFsV2lkdGggPSAtdGhpcy5tYXhTY3JvbGxYCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICBjb25zdCBidG4gPSB0aGlzLiRyZWZzLmJ0bnNbaV0KICAgICAgICBsZXQgcmF0ZSA9ICh0b3RhbFdpZHRoIC0gZGVsdGEpIC8gdG90YWxXaWR0aAogICAgICAgIGxldCB3aWR0aAogICAgICAgIGxldCB0cmFuc2xhdGUgPSByYXRlICogeCAtIHgKICAgICAgICBpZiAoeCA8IHRoaXMubWF4U2Nyb2xsWCkgewogICAgICAgICAgd2lkdGggPSB0aGlzLmNhY2hlZEJ0bnNbaV0ud2lkdGggKyByYXRlICogKHRoaXMubWF4U2Nyb2xsWCAtIHgpCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHdpZHRoID0gdGhpcy5jYWNoZWRCdG5zW2ldLndpZHRoCiAgICAgICAgfQogICAgICAgIGRlbHRhICs9IHRoaXMuY2FjaGVkQnRuc1tpXS53aWR0aAogICAgICAgIGJ0bi5zdHlsZS53aWR0aCA9IGAke3dpZHRofXB4YAogICAgICAgIGJ0bi5zdHlsZVt0cmFuc2Zvcm1dID0gYHRyYW5zbGF0ZSgke3RyYW5zbGF0ZX1weClgCiAgICAgICAgYnRuLnN0eWxlW3RyYW5zaXRpb25EdXJhdGlvbl0gPSAnMG1zJwogICAgICB9CiAgICB9LAogICAgX2lzSW5CdG5zKHRhcmdldCkgewogICAgICBsZXQgcGFyZW50ID0gdGFyZ2V0CiAgICAgIGxldCBmbGFnID0gZmFsc2UKICAgICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQuY2xhc3NOYW1lLmluZGV4T2YoJ2N1YmUtc3dpcGUtaXRlbScpIDwgMCkgewogICAgICAgIGlmIChwYXJlbnQuY2xhc3NOYW1lLmluZGV4T2YoJ2N1YmUtc3dpcGUtYnRucycpID49IDApIHsKICAgICAgICAgIGZsYWcgPSB0cnVlCiAgICAgICAgICBicmVhawogICAgICAgIH0KICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZQogICAgICB9CiAgICAgIHJldHVybiBmbGFnCiAgICB9LAogICAgX2NhbGN1bGF0ZUJ0bnNXaWR0aCgpIHsKICAgICAgbGV0IHdpZHRoID0gMAogICAgICBjb25zdCBsZW4gPSB0aGlzLmNhY2hlZEJ0bnMubGVuZ3RoCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICB3aWR0aCArPSB0aGlzLmNhY2hlZEJ0bnNbaV0ud2lkdGgKICAgICAgfQogICAgICB0aGlzLm1heFNjcm9sbFggPSAtd2lkdGgKICAgIH0sCiAgICBfdHJhbnNsYXRlKHgsIHVzZVopIHsKICAgICAgbGV0IHRyYW5zbGF0ZVogPSB1c2VaID8gJyB0cmFuc2xhdGVaKDApJyA6ICcnCiAgICAgIHRoaXMuc2Nyb2xsZXJTdHlsZVt0cmFuc2Zvcm1dID0gYHRyYW5zbGF0ZSgke3h9cHgsMCkke3RyYW5zbGF0ZVp9YAogICAgICB0aGlzLnggPSB4CiAgICB9LAogICAgX3RyYW5zaXRpb25Qcm9wZXJ0eShwcm9wZXJ0eSA9ICd0cmFuc2Zvcm0nKSB7CiAgICAgIHRoaXMuc2Nyb2xsZXJTdHlsZVt0cmFuc2l0aW9uUHJvcGVydHldID0gcHJvcGVydHkKICAgIH0sCiAgICBfdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uKGVhc2luZykgewogICAgICB0aGlzLnNjcm9sbGVyU3R5bGVbdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uXSA9IGVhc2luZwogICAgfSwKICAgIF90cmFuc2l0aW9uVGltZSh0aW1lID0gMCkgewogICAgICB0aGlzLnNjcm9sbGVyU3R5bGVbdHJhbnNpdGlvbkR1cmF0aW9uXSA9IGAke3RpbWV9bXNgCiAgICB9LAogICAgX2dldENvbXB1dGVkUG9zaXRpb25YKCkgewogICAgICBsZXQgbWF0cml4ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy4kcmVmcy5zd2lwZUl0ZW0sIG51bGwpCiAgICAgIG1hdHJpeCA9IG1hdHJpeFt0cmFuc2Zvcm1dLnNwbGl0KCcpJylbMF0uc3BsaXQoJywgJykKICAgICAgbGV0IHggPSArKG1hdHJpeFsxMl0gfHwgbWF0cml4WzRdKQogICAgICByZXR1cm4geAogICAgfSwKICAgIF90cmFuc2xhdGVCdG5zKHRpbWUsIGVhc2luZywgZXh0ZW5kKSB7CiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLwogICAgICBpZiAodGhpcy5idG5zLmxlbmd0aCA9PT0gMCkgewogICAgICAgIHJldHVybgogICAgICB9CiAgICAgIGNvbnN0IGxlbiA9IHRoaXMuJHJlZnMuYnRucy5sZW5ndGgKICAgICAgbGV0IGRlbHRhID0gMAogICAgICBsZXQgdHJhbnNsYXRlID0gMAogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgY29uc3QgYnRuID0gdGhpcy4kcmVmcy5idG5zW2ldCiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNUQVRFX0dST1cpIHsKICAgICAgICAgIHRyYW5zbGF0ZSA9IGRlbHRhCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRyYW5zbGF0ZSA9IDAKICAgICAgICB9CiAgICAgICAgZGVsdGEgKz0gdGhpcy5jYWNoZWRCdG5zW2ldLndpZHRoCiAgICAgICAgYnRuLnN0eWxlW3RyYW5zZm9ybV0gPSBgdHJhbnNsYXRlKCR7dHJhbnNsYXRlfXB4LDApIHRyYW5zbGF0ZVooMClgCiAgICAgICAgYnRuLnN0eWxlW3RyYW5zaXRpb25Qcm9wZXJ0eV0gPSAnYWxsJwogICAgICAgIGJ0bi5zdHlsZVt0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb25dID0gZWFzaW5nCiAgICAgICAgYnRuLnN0eWxlW3RyYW5zaXRpb25EdXJhdGlvbl0gPSBgJHt0aW1lfW1zYAogICAgICAgIGlmIChleHRlbmQpIHsKICAgICAgICAgIGJ0bi5zdHlsZS53aWR0aCA9IGAke3RoaXMuY2FjaGVkQnRuc1tpXS53aWR0aH1weGAKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICByZWZyZXNoKCkgewogICAgICBpZiAodGhpcy5idG5zLmxlbmd0aCA+IDApIHsKICAgICAgICB0aGlzLl9pbml0Q2FjaGVkQnRucygpCiAgICAgICAgdGhpcy5fY2FsY3VsYXRlQnRuc1dpZHRoKCkKICAgICAgfQogICAgICB0aGlzLmVuZFRpbWUgPSAwCiAgICB9LAogICAgc2hyaW5rKCkgewogICAgICB0aGlzLnN0b3AoKQogICAgICB0aGlzLnN0YXRlID0gU1RBVEVfU0hSSU5LCiAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsKICAgICAgICB0aGlzLnNjcm9sbFRvKDAsIGVhc2luZ1RpbWUsIGVhc2VPdXRRdWFydCkKICAgICAgICB0aGlzLl90cmFuc2xhdGVCdG5zKGVhc2luZ1RpbWUsIGVhc2VPdXRRdWFydCkKICAgICAgfSkKICAgIH0sCiAgICBncm93KCkgewogICAgICB0aGlzLnN0YXRlID0gU1RBVEVfR1JPVwogICAgICBjb25zdCBleHRlbmQgPSB0aGlzLnggPCB0aGlzLm1heFNjcm9sbFgKICAgICAgbGV0IGVhc2luZyA9IGVhc2VPdXRDdWJpYwogICAgICB0aGlzLnNjcm9sbFRvKHRoaXMubWF4U2Nyb2xsWCwgZWFzaW5nVGltZSwgZWFzaW5nKQogICAgICB0aGlzLl90cmFuc2xhdGVCdG5zKGVhc2luZ1RpbWUsIGVhc2luZywgZXh0ZW5kKQogICAgfSwKICAgIHNjcm9sbFRvKHgsIHRpbWUsIGVhc2luZykgewogICAgICB0aGlzLl90cmFuc2l0aW9uUHJvcGVydHkoKQogICAgICB0aGlzLl90cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24oZWFzaW5nKQogICAgICB0aGlzLl90cmFuc2l0aW9uVGltZSh0aW1lKQogICAgICB0aGlzLl90cmFuc2xhdGUoeCwgdHJ1ZSkKICAgICAgaWYgKHRpbWUpIHsKICAgICAgICB0aGlzLmlzSW5UcmFuc2l0aW9uID0gdHJ1ZQogICAgICB9CiAgICB9LAogICAgZ2VuQnRuU3R5bChidG4pIHsKICAgICAgcmV0dXJuIGBiYWNrZ3JvdW5kOiAke2J0bi5jb2xvcn1gCiAgICB9LAogICAgY2xpY2tJdGVtKCkgewogICAgICB0aGlzLnN3aXBlLm9uSXRlbUNsaWNrKHRoaXMuaXRlbSwgdGhpcy5pbmRleCkKICAgICAgdGhpcy4kZW1pdChFVkVOVF9JVEVNX0NMSUNLLCB0aGlzLml0ZW0sIHRoaXMuaW5kZXgpCiAgICB9LAogICAgY2xpY2tCdG4oYnRuKSB7CiAgICAgIHRoaXMuc3dpcGUub25CdG5DbGljayhidG4sIHRoaXMuaW5kZXgpCiAgICAgIHRoaXMuJGVtaXQoRVZFTlRfQlROX0NMSUNLLCBidG4sIHRoaXMuaW5kZXgpCiAgICAgIGlmICh0aGlzLmF1dG9TaHJpbmspIHsKICAgICAgICB0aGlzLnNocmluaygpCiAgICAgIH0KICAgIH0sCiAgICBzdG9wKCkgewogICAgICBpZiAodGhpcy5pc0luVHJhbnNpdGlvbikgewogICAgICAgIHRoaXMuaXNJblRyYW5zaXRpb24gPSBmYWxzZQogICAgICAgIGxldCB4ID0gdGhpcy5zdGF0ZSA9PT0gU1RBVEVfU0hSSU5LID8gMCA6IHRoaXMuX2dldENvbXB1dGVkUG9zaXRpb25YKCkKICAgICAgICB0aGlzLl90cmFuc2xhdGUoeCkKICAgICAgICB0aGlzLiRlbWl0KEVWRU5UX1NDUk9MTCwgdGhpcy54KQogICAgICB9CiAgICB9LAogICAgb25Ub3VjaFN0YXJ0KGUpIHsKICAgICAgdGhpcy5zd2lwZS5vbkl0ZW1BY3RpdmUodGhpcy5pbmRleCkKICAgICAgdGhpcy4kZW1pdChFVkVOVF9BQ1RJVkUsIHRoaXMuaW5kZXgpCiAgICAgIHRoaXMuc3RvcCgpCiAgICAgIHRoaXMubW92ZWQgPSBmYWxzZQogICAgICB0aGlzLm1vdmluZ0RpcmVjdGlvblggPSAwCiAgICAgIGNvbnN0IHBvaW50ID0gZS50b3VjaGVzWzBdCiAgICAgIHRoaXMucG9pbnRYID0gcG9pbnQucGFnZVgKICAgICAgdGhpcy5wb2ludFkgPSBwb2ludC5wYWdlWQogICAgICB0aGlzLmRpc3RYID0gMAogICAgICB0aGlzLmRpc3RZID0gMAogICAgICB0aGlzLnN0YXJ0WCA9IHRoaXMueAogICAgICB0aGlzLl90cmFuc2l0aW9uVGltZSgpCiAgICAgIHRoaXMuc3RhcnRUaW1lID0gZ2V0Tm93KCkKICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNUQVRFX0dST1cgJiYgIXRoaXMuX2lzSW5CdG5zKGUudGFyZ2V0KSkgewogICAgICAgIHRoaXMuc2hyaW5rVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgIHRoaXMuc2hyaW5rKCkKICAgICAgICB9LCAzMDApCiAgICAgIH0KICAgIH0sCiAgICBvblRvdWNoTW92ZShlKSB7CiAgICAgIGlmICh0aGlzLm1vdmVkKSB7CiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2hyaW5rVGltZXIpCiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKQogICAgICB9CiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLwogICAgICBpZiAodGhpcy5pc0luVHJhbnNpdGlvbikgewogICAgICAgIHJldHVybgogICAgICB9CiAgICAgIGUucHJldmVudERlZmF1bHQoKQogICAgICBjb25zdCBwb2ludCA9IGUudG91Y2hlc1swXQogICAgICBsZXQgZGVsdGFYID0gcG9pbnQucGFnZVggLSB0aGlzLnBvaW50WAogICAgICBsZXQgZGVsdGFZID0gcG9pbnQucGFnZVkgLSB0aGlzLnBvaW50WQogICAgICB0aGlzLnBvaW50WCA9IHBvaW50LnBhZ2VYCiAgICAgIHRoaXMucG9pbnRZID0gcG9pbnQucGFnZVkKCiAgICAgIHRoaXMuZGlzdFggKz0gZGVsdGFYCiAgICAgIHRoaXMuZGlzdFkgKz0gZGVsdGFZCiAgICAgIGxldCBhYnNEaXN0WCA9IE1hdGguYWJzKHRoaXMuZGlzdFgpCiAgICAgIGxldCBhYnNEaXN0WSA9IE1hdGguYWJzKHRoaXMuZGlzdFkpCgogICAgICBpZiAoYWJzRGlzdFggKyBkaXJlY3Rpb25Mb2NrVGhyZXNob2xkIDw9IGFic0Rpc3RZKSB7CiAgICAgICAgcmV0dXJuCiAgICAgIH0KCiAgICAgIGxldCB0aW1lc3RhbXAgPSBnZXROb3coKQogICAgICBpZiAodGltZXN0YW1wIC0gdGhpcy5lbmRUaW1lID4gbW9tZW50dW1MaW1pdFRpbWUgJiYgYWJzRGlzdFggPCBtb21lbnR1bUxpbWl0RGlzdGFuY2UpIHsKICAgICAgICByZXR1cm4KICAgICAgfQoKICAgICAgdGhpcy5tb3ZpbmdEaXJlY3Rpb25YID0gZGVsdGFYID4gMCA/IERJUkVDVElPTl9SSUdIVCA6IGRlbHRhWCA8IDAgPyBESVJFQ1RJT05fTEVGVCA6IDAKCiAgICAgIGxldCBuZXdYID0gdGhpcy54ICsgZGVsdGFYCiAgICAgIGlmIChuZXdYID4gMCkgewogICAgICAgIG5ld1ggPSAwCiAgICAgIH0KICAgICAgaWYgKG5ld1ggPCB0aGlzLm1heFNjcm9sbFgpIHsKICAgICAgICBuZXdYID0gdGhpcy54ICsgZGVsdGFYIC8gMwogICAgICB9CiAgICAgIGlmICghdGhpcy5tb3ZlZCkgewogICAgICAgIHRoaXMubW92ZWQgPSB0cnVlCiAgICAgIH0KCiAgICAgIHRoaXMuX3RyYW5zbGF0ZShuZXdYLCB0cnVlKQoKICAgICAgaWYgKHRpbWVzdGFtcCAtIHRoaXMuc3RhcnRUaW1lID4gbW9tZW50dW1MaW1pdFRpbWUpIHsKICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHRpbWVzdGFtcAogICAgICAgIHRoaXMuc3RhcnRYID0gdGhpcy54CiAgICAgIH0KCiAgICAgIHRoaXMuJGVtaXQoRVZFTlRfU0NST0xMLCB0aGlzLngpCiAgICB9LAogICAgb25Ub3VjaEVuZCgpIHsKICAgICAgaWYgKCF0aGlzLm1vdmVkKSB7CiAgICAgICAgcmV0dXJuCiAgICAgIH0KICAgICAgaWYgKHRoaXMubW92aW5nRGlyZWN0aW9uWCA9PT0gRElSRUNUSU9OX1JJR0hUKSB7CiAgICAgICAgdGhpcy5zaHJpbmsoKQogICAgICAgIHJldHVybgogICAgICB9CiAgICAgIHRoaXMuZW5kVGltZSA9IGdldE5vdygpCiAgICAgIGxldCBkdXJhdGlvbiA9IHRoaXMuZW5kVGltZSAtIHRoaXMuc3RhcnRUaW1lCiAgICAgIGxldCBhYnNEaXN0WCA9IE1hdGguYWJzKHRoaXMueCAtIHRoaXMuc3RhcnRYKQogICAgICBpZiAoKGR1cmF0aW9uIDwgbW9tZW50dW1MaW1pdFRpbWUgJiYgYWJzRGlzdFggPiBtb21lbnR1bUxpbWl0RGlzdGFuY2UpIHx8IHRoaXMueCA8IHRoaXMubWF4U2Nyb2xsWCAvIDIpIHsKICAgICAgICB0aGlzLmdyb3coKQogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuc2hyaW5rKCkKICAgICAgfQogICAgfSwKICAgIG9uVHJhbnNpdGlvbkVuZCgpIHsKICAgICAgdGhpcy5pc0luVHJhbnNpdGlvbiA9IGZhbHNlCiAgICAgIHRoaXMuX3RyYW5zaXRpb25UaW1lKCkKICAgICAgdGhpcy5fdHJhbnNsYXRlKHRoaXMueCkKICAgIH0KICB9LAogIGJlZm9yZURlc3Ryb3koKSB7CiAgICB0aGlzLnN3aXBlLnJlbW92ZUl0ZW0odGhpcykKICB9Cn0K"},{"version":3,"sources":["swipe-item.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"swipe-item.vue","sourceRoot":"node_modules/cube-ui/src/components/swipe","sourcesContent":["<template>\n  <div ref=\"swipeItem\"\n       @transitionend=\"onTransitionEnd\"\n       @touchstart=\"onTouchStart\"\n       @touchmove=\"onTouchMove\"\n       @touchend=\"onTouchEnd\"\n       class=\"cube-swipe-item\">\n    <slot>\n      <div @click=\"clickItem\" class=\"cube-swipe-item-inner border-bottom-1px\">\n        <span>{{item.text}}</span>\n      </div>\n    </slot>\n    <ul class=\"cube-swipe-btns\">\n      <li ref=\"btns\"\n          v-for=\"btn in btns\"\n          class=\"cube-swipe-btn\"\n          :style=\"genBtnStyl(btn)\"\n          @click.prevent=\"clickBtn(btn)\">\n        <span class=\"text\">{{btn.text}}</span>\n      </li>\n    </ul>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\n  import {\n    getRect,\n    prefixStyle\n  } from '../../common/helpers/dom'\n\n  import { easeOutQuart, easeOutCubic } from '../../common/helpers/ease'\n  import { getNow } from '../../common/lang/date'\n\n  const COMPONENT_NAME = 'cube-swipe-item'\n  const EVENT_ITEM_CLICK = 'item-click'\n  const EVENT_BTN_CLICK = 'btn-click'\n  const EVENT_SCROLL = 'scroll'\n  const EVENT_ACTIVE = 'active'\n  const DIRECTION_LEFT = 1\n  const DIRECTION_RIGHT = -1\n  const STATE_SHRINK = 0\n  const STATE_GROW = 1\n  const easingTime = 600\n  const momentumLimitTime = 300\n  const momentumLimitDistance = 15\n  const directionLockThreshold = 5\n\n  const transform = prefixStyle('transform')\n  const transitionProperty = prefixStyle('transitionProperty')\n  const transitionDuration = prefixStyle('transitionDuration')\n  const transitionTimingFunction = prefixStyle('transitionTimingFunction')\n\n  export default {\n    name: COMPONENT_NAME,\n    inject: ['swipe'],\n    props: {\n      item: {\n        type: Object,\n        default() {\n          return {}\n        }\n      },\n      btns: {\n        type: Array,\n        default() {\n          return []\n        }\n      },\n      index: {\n        type: Number,\n        index: -1\n      },\n      autoShrink: {\n        type: Boolean,\n        default: false\n      }\n    },\n    watch: {\n      btns() {\n        this.$nextTick(() => {\n          this.refresh()\n        })\n      }\n    },\n    created() {\n      this.x = 0\n      this.state = STATE_SHRINK\n      this.swipe.addItem(this)\n    },\n    mounted() {\n      this.scrollerStyle = this.$refs.swipeItem.style\n      this.$nextTick(() => {\n        this.refresh()\n      })\n      this.$on(EVENT_SCROLL, this._handleBtns)\n    },\n    methods: {\n      _initCachedBtns() {\n        this.cachedBtns = []\n        const len = this.$refs.btns.length\n        for (let i = 0; i < len; i++) {\n          this.cachedBtns.push({\n            width: getRect(this.$refs.btns[i]).width\n          })\n        }\n      },\n      _handleBtns(x) {\n        /* istanbul ignore if */\n        if (this.btns.length === 0) {\n          return\n        }\n        const len = this.$refs.btns.length\n        let delta = 0\n        let totalWidth = -this.maxScrollX\n        for (let i = 0; i < len; i++) {\n          const btn = this.$refs.btns[i]\n          let rate = (totalWidth - delta) / totalWidth\n          let width\n          let translate = rate * x - x\n          if (x < this.maxScrollX) {\n            width = this.cachedBtns[i].width + rate * (this.maxScrollX - x)\n          } else {\n            width = this.cachedBtns[i].width\n          }\n          delta += this.cachedBtns[i].width\n          btn.style.width = `${width}px`\n          btn.style[transform] = `translate(${translate}px)`\n          btn.style[transitionDuration] = '0ms'\n        }\n      },\n      _isInBtns(target) {\n        let parent = target\n        let flag = false\n        while (parent && parent.className.indexOf('cube-swipe-item') < 0) {\n          if (parent.className.indexOf('cube-swipe-btns') >= 0) {\n            flag = true\n            break\n          }\n          parent = parent.parentNode\n        }\n        return flag\n      },\n      _calculateBtnsWidth() {\n        let width = 0\n        const len = this.cachedBtns.length\n        for (let i = 0; i < len; i++) {\n          width += this.cachedBtns[i].width\n        }\n        this.maxScrollX = -width\n      },\n      _translate(x, useZ) {\n        let translateZ = useZ ? ' translateZ(0)' : ''\n        this.scrollerStyle[transform] = `translate(${x}px,0)${translateZ}`\n        this.x = x\n      },\n      _transitionProperty(property = 'transform') {\n        this.scrollerStyle[transitionProperty] = property\n      },\n      _transitionTimingFunction(easing) {\n        this.scrollerStyle[transitionTimingFunction] = easing\n      },\n      _transitionTime(time = 0) {\n        this.scrollerStyle[transitionDuration] = `${time}ms`\n      },\n      _getComputedPositionX() {\n        let matrix = window.getComputedStyle(this.$refs.swipeItem, null)\n        matrix = matrix[transform].split(')')[0].split(', ')\n        let x = +(matrix[12] || matrix[4])\n        return x\n      },\n      _translateBtns(time, easing, extend) {\n        /* istanbul ignore if */\n        if (this.btns.length === 0) {\n          return\n        }\n        const len = this.$refs.btns.length\n        let delta = 0\n        let translate = 0\n        for (let i = 0; i < len; i++) {\n          const btn = this.$refs.btns[i]\n          if (this.state === STATE_GROW) {\n            translate = delta\n          } else {\n            translate = 0\n          }\n          delta += this.cachedBtns[i].width\n          btn.style[transform] = `translate(${translate}px,0) translateZ(0)`\n          btn.style[transitionProperty] = 'all'\n          btn.style[transitionTimingFunction] = easing\n          btn.style[transitionDuration] = `${time}ms`\n          if (extend) {\n            btn.style.width = `${this.cachedBtns[i].width}px`\n          }\n        }\n      },\n      refresh() {\n        if (this.btns.length > 0) {\n          this._initCachedBtns()\n          this._calculateBtnsWidth()\n        }\n        this.endTime = 0\n      },\n      shrink() {\n        this.stop()\n        this.state = STATE_SHRINK\n        this.$nextTick(() => {\n          this.scrollTo(0, easingTime, easeOutQuart)\n          this._translateBtns(easingTime, easeOutQuart)\n        })\n      },\n      grow() {\n        this.state = STATE_GROW\n        const extend = this.x < this.maxScrollX\n        let easing = easeOutCubic\n        this.scrollTo(this.maxScrollX, easingTime, easing)\n        this._translateBtns(easingTime, easing, extend)\n      },\n      scrollTo(x, time, easing) {\n        this._transitionProperty()\n        this._transitionTimingFunction(easing)\n        this._transitionTime(time)\n        this._translate(x, true)\n        if (time) {\n          this.isInTransition = true\n        }\n      },\n      genBtnStyl(btn) {\n        return `background: ${btn.color}`\n      },\n      clickItem() {\n        this.swipe.onItemClick(this.item, this.index)\n        this.$emit(EVENT_ITEM_CLICK, this.item, this.index)\n      },\n      clickBtn(btn) {\n        this.swipe.onBtnClick(btn, this.index)\n        this.$emit(EVENT_BTN_CLICK, btn, this.index)\n        if (this.autoShrink) {\n          this.shrink()\n        }\n      },\n      stop() {\n        if (this.isInTransition) {\n          this.isInTransition = false\n          let x = this.state === STATE_SHRINK ? 0 : this._getComputedPositionX()\n          this._translate(x)\n          this.$emit(EVENT_SCROLL, this.x)\n        }\n      },\n      onTouchStart(e) {\n        this.swipe.onItemActive(this.index)\n        this.$emit(EVENT_ACTIVE, this.index)\n        this.stop()\n        this.moved = false\n        this.movingDirectionX = 0\n        const point = e.touches[0]\n        this.pointX = point.pageX\n        this.pointY = point.pageY\n        this.distX = 0\n        this.distY = 0\n        this.startX = this.x\n        this._transitionTime()\n        this.startTime = getNow()\n        if (this.state === STATE_GROW && !this._isInBtns(e.target)) {\n          this.shrinkTimer = setTimeout(() => {\n            this.shrink()\n          }, 300)\n        }\n      },\n      onTouchMove(e) {\n        if (this.moved) {\n          clearTimeout(this.shrinkTimer)\n          e.stopPropagation()\n        }\n        /* istanbul ignore if */\n        if (this.isInTransition) {\n          return\n        }\n        e.preventDefault()\n        const point = e.touches[0]\n        let deltaX = point.pageX - this.pointX\n        let deltaY = point.pageY - this.pointY\n        this.pointX = point.pageX\n        this.pointY = point.pageY\n\n        this.distX += deltaX\n        this.distY += deltaY\n        let absDistX = Math.abs(this.distX)\n        let absDistY = Math.abs(this.distY)\n\n        if (absDistX + directionLockThreshold <= absDistY) {\n          return\n        }\n\n        let timestamp = getNow()\n        if (timestamp - this.endTime > momentumLimitTime && absDistX < momentumLimitDistance) {\n          return\n        }\n\n        this.movingDirectionX = deltaX > 0 ? DIRECTION_RIGHT : deltaX < 0 ? DIRECTION_LEFT : 0\n\n        let newX = this.x + deltaX\n        if (newX > 0) {\n          newX = 0\n        }\n        if (newX < this.maxScrollX) {\n          newX = this.x + deltaX / 3\n        }\n        if (!this.moved) {\n          this.moved = true\n        }\n\n        this._translate(newX, true)\n\n        if (timestamp - this.startTime > momentumLimitTime) {\n          this.startTime = timestamp\n          this.startX = this.x\n        }\n\n        this.$emit(EVENT_SCROLL, this.x)\n      },\n      onTouchEnd() {\n        if (!this.moved) {\n          return\n        }\n        if (this.movingDirectionX === DIRECTION_RIGHT) {\n          this.shrink()\n          return\n        }\n        this.endTime = getNow()\n        let duration = this.endTime - this.startTime\n        let absDistX = Math.abs(this.x - this.startX)\n        if ((duration < momentumLimitTime && absDistX > momentumLimitDistance) || this.x < this.maxScrollX / 2) {\n          this.grow()\n        } else {\n          this.shrink()\n        }\n      },\n      onTransitionEnd() {\n        this.isInTransition = false\n        this._transitionTime()\n        this._translate(this.x)\n      }\n    },\n    beforeDestroy() {\n      this.swipe.removeItem(this)\n    }\n  }\n</script>\n\n<style lang=\"stylus\" rel=\"stylesheet/stylus\">\n  @require \"../../common/stylus/variable.styl\"\n  .cube-swipe-item\n    position: relative\n\n  .cube-swipe-item-inner\n    height: 60px\n    line-height: 60px\n    font-size: $fontsize-large\n    padding-left: 20px\n\n  .cube-swipe-btn\n    display: flex\n    align-items: center\n    position: absolute\n    top: 0\n    left: 100%\n    height: 100%\n    text-align: left\n    font-size: $fontsize-large\n    .text\n      flex: 1\n      padding: 0 20px\n      white-space: nowrap\n      color: $swipe-btn-color\n</style>\n"]}]}