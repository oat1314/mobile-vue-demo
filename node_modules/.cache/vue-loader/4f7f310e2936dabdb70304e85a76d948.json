{"remainingRequest":"F:\\BaiduNetdiskDownload\\思否\\20年spring boot+vue课程源码\\课程源码\\00-前端-后端代码-数据库\\xdclass_front\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!F:\\BaiduNetdiskDownload\\思否\\20年spring boot+vue课程源码\\课程源码\\00-前端-后端代码-数据库\\xdclass_front\\node_modules\\cube-ui\\src\\components\\time-picker\\time-picker.vue?vue&type=script&lang=js&","dependencies":[{"path":"F:\\BaiduNetdiskDownload\\思否\\20年spring boot+vue课程源码\\课程源码\\00-前端-后端代码-数据库\\xdclass_front\\node_modules\\cube-ui\\src\\components\\time-picker\\time-picker.vue","mtime":499162500000},{"path":"F:\\BaiduNetdiskDownload\\思否\\20年spring boot+vue课程源码\\课程源码\\00-前端-后端代码-数据库\\xdclass_front\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"F:\\BaiduNetdiskDownload\\思否\\20年spring boot+vue课程源码\\课程源码\\00-前端-后端代码-数据库\\xdclass_front\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"F:\\BaiduNetdiskDownload\\思否\\20年spring boot+vue课程源码\\课程源码\\00-前端-后端代码-数据库\\xdclass_front\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"F:\\BaiduNetdiskDownload\\思否\\20年spring boot+vue课程源码\\课程源码\\00-前端-后端代码-数据库\\xdclass_front\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCB7CiAgcGFkLAogIGZvcm1hdERhdGUsCiAgZ2V0WmVyb1N0YW1wLAogIGdldERheURpZmYsCiAgREFZX1RJTUVTVEFNUCwKICBIT1VSX1RJTUVTVEFNUCwKICBNSU5VVEVfVElNRVNUQU1QCn0gZnJvbSAnLi4vLi4vY29tbW9uL2xhbmcvZGF0ZScKaW1wb3J0IHZpc2liaWxpdHlNaXhpbiBmcm9tICcuLi8uLi9jb21tb24vbWl4aW5zL3Zpc2liaWxpdHknCmltcG9ydCBwb3B1cE1peGluIGZyb20gJy4uLy4uL2NvbW1vbi9taXhpbnMvcG9wdXAnCmltcG9ydCBwaWNrZXJNaXhpbiBmcm9tICcuLi8uLi9jb21tb24vbWl4aW5zL3BpY2tlcicKaW1wb3J0IGxvY2FsZU1peGluIGZyb20gJy4uLy4uL2NvbW1vbi9taXhpbnMvbG9jYWxlJwppbXBvcnQgQ3ViZUNhc2NhZGVQaWNrZXIgZnJvbSAnLi4vY2FzY2FkZS1waWNrZXIvY2FzY2FkZS1waWNrZXIudnVlJwppbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vY29tbW9uL2hlbHBlcnMvZGVidWcnCgpjb25zdCBDT01QT05FTlRfTkFNRSA9ICdjdWJlLXRpbWUtcGlja2VyJwpjb25zdCBFVkVOVF9TRUxFQ1QgPSAnc2VsZWN0Jwpjb25zdCBFVkVOVF9DQU5DRUwgPSAnY2FuY2VsJwpjb25zdCBFVkVOVF9DSEFOR0UgPSAnY2hhbmdlJwoKY29uc3QgTk9XID0gewogIHZhbHVlOiAnbm93Jwp9Cgpjb25zdCBJTlRfUlVMRSA9IHsKICBmbG9vcjogJ2Zsb29yJywKICBjZWlsOiAnY2VpbCcsCiAgcm91bmQ6ICdyb3VuZCcKfQoKY29uc3QgREVGQVVMVF9TVEVQID0gMTAKCmV4cG9ydCBkZWZhdWx0IHsKICBuYW1lOiBDT01QT05FTlRfTkFNRSwKICBtaXhpbnM6IFt2aXNpYmlsaXR5TWl4aW4sIHBvcHVwTWl4aW4sIHBpY2tlck1peGluLCBsb2NhbGVNaXhpbl0sCiAgY29tcG9uZW50czogewogICAgQ3ViZUNhc2NhZGVQaWNrZXIKICB9LAogIHByb3BzOiB7CiAgICB0aXRsZTogewogICAgICB0eXBlOiBTdHJpbmcsCiAgICAgIGRlZmF1bHQ6ICcnCiAgICB9LAogICAgZGVsYXk6IHsKICAgICAgdHlwZTogTnVtYmVyLAogICAgICBkZWZhdWx0OiAxNQogICAgfSwKICAgIGRheTogewogICAgICB0eXBlOiBPYmplY3QsCiAgICAgIGRlZmF1bHQoKSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIGxlbjogMwogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgIHNob3dOb3c6IHsKICAgICAgdHlwZTogW0Jvb2xlYW4sIE9iamVjdF0sCiAgICAgIGRlZmF1bHQ6IHRydWUKICAgIH0sCiAgICBtaW51dGVTdGVwOiB7CiAgICAgIHR5cGU6IFtOdW1iZXIsIE9iamVjdF0sCiAgICAgIGRlZmF1bHQ6IERFRkFVTFRfU1RFUAogICAgfSwKICAgIGZvcm1hdDogewogICAgICB0eXBlOiBTdHJpbmcsCiAgICAgIGRlZmF1bHQ6ICdZWVlZL00vRCBoaDptbScKICAgIH0sCiAgICBtaW46IHsKICAgICAgdHlwZTogW0RhdGUsIE51bWJlcl0sCiAgICAgIGRlZmF1bHQ6IG51bGwKICAgIH0sCiAgICBtYXg6IHsKICAgICAgdHlwZTogW0RhdGUsIE51bWJlcl0sCiAgICAgIGRlZmF1bHQ6IG51bGwKICAgIH0KICB9LAogIGRhdGEoKSB7CiAgICByZXR1cm4gewogICAgICBub3c6IG5ldyBEYXRlKCksCiAgICAgIHNlbGVjdGVkSW5kZXg6IFswLCAwLCAwXSwKICAgICAgdmFsdWU6IDAKICAgIH0KICB9LAogIGNvbXB1dGVkOiB7CiAgICBfdGl0bGUgKCkgewogICAgICByZXR1cm4gdGhpcy50aXRsZSB8fCB0aGlzLiR0KCdzZWxlY3RUaW1lJykKICAgIH0sCiAgICBfZGF5ICgpIHsKICAgICAgY29uc3QgZGVmYXVsdERheSA9IHsKICAgICAgICBmaWx0ZXI6IFt0aGlzLiR0KCd0b2RheScpXSwKICAgICAgICBmb3JtYXQ6IHRoaXMuJHQoJ2Zvcm1hdERhdGUnKQogICAgICB9CiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0RGF5LCB0aGlzLmRheSkKICAgIH0sCiAgICBub3dUZXh0KCkgewogICAgICBjb25zdCBkZWZhdWx0VGV4dCA9IHRoaXMuJHQoJ25vdycpCiAgICAgIHJldHVybiAodGhpcy5zaG93Tm93ICYmIHRoaXMuc2hvd05vdy50ZXh0KSB8fCBkZWZhdWx0VGV4dAogICAgfSwKICAgIG1pbnV0ZVN0ZXBSdWxlKCkgewogICAgICBjb25zdCBtaW51dGVTdGVwID0gdGhpcy5taW51dGVTdGVwCiAgICAgIHJldHVybiAodHlwZW9mIG1pbnV0ZVN0ZXAgPT09ICdvYmplY3QnICYmIE1hdGhbSU5UX1JVTEVbbWludXRlU3RlcC5ydWxlXV0pIHx8IE1hdGhbSU5UX1JVTEUuZmxvb3JdCiAgICB9LAogICAgbWludXRlU3RlcE51bWJlcigpIHsKICAgICAgY29uc3QgbWludXRlU3RlcCA9IHRoaXMubWludXRlU3RlcAogICAgICByZXR1cm4gdHlwZW9mIG1pbnV0ZVN0ZXAgPT09ICdudW1iZXInID8gbWludXRlU3RlcCA6IChtaW51dGVTdGVwLnN0ZXAgfHwgREVGQVVMVF9TVEVQKQogICAgfSwKICAgIG1pblRpbWUoKSB7CiAgICAgIGxldCBtaW5UaW1lU3RhbXAgPSArdGhpcy5taW4gfHwgK3RoaXMubm93ICsgdGhpcy5kZWxheSAqIE1JTlVURV9USU1FU1RBTVAKCiAgICAgIC8vIEhhbmRsZSB0aGUgbWluVGltZSBzZWxlY3RhYmxlIGNoYW5nZSBjYXVzZWQgYnkgbWludXRlIHN0ZXAuCiAgICAgIGNvbnN0IG1pbnV0ZSA9IG5ldyBEYXRlKG1pblRpbWVTdGFtcCkuZ2V0TWludXRlcygpCiAgICAgIGNvbnN0IGludE1pbnV0ZSA9IE1hdGgubWluKHRoaXMubWludXRlU3RlcFJ1bGUobWludXRlIC8gdGhpcy5taW51dGVTdGVwTnVtYmVyKSAqIHRoaXMubWludXRlU3RlcE51bWJlciwgNjApCgogICAgICBtaW5UaW1lU3RhbXAgKz0gKGludE1pbnV0ZSAtIG1pbnV0ZSkgKiBNSU5VVEVfVElNRVNUQU1QCiAgICAgIHJldHVybiBuZXcgRGF0ZShtaW5UaW1lU3RhbXApCiAgICB9LAogICAgbWF4VGltZSgpIHsKICAgICAgbGV0IG1heFRpbWVTdGFtcCA9ICt0aGlzLm1heCB8fCAoZ2V0WmVyb1N0YW1wKG5ldyBEYXRlKCt0aGlzLm1pblRpbWUgKyB0aGlzLl9kYXkubGVuICogREFZX1RJTUVTVEFNUCkpIC0gMSkKCiAgICAgIGNvbnN0IG1pbnV0ZSA9IG5ldyBEYXRlKG1heFRpbWVTdGFtcCkuZ2V0TWludXRlcygpCiAgICAgIGNvbnN0IGludE1pbnV0ZSA9IE1hdGguZmxvb3IobWludXRlIC8gdGhpcy5taW51dGVTdGVwTnVtYmVyKSAqIHRoaXMubWludXRlU3RlcE51bWJlcgogICAgICBtYXhUaW1lU3RhbXAgLT0gKG1pbnV0ZSAtIGludE1pbnV0ZSkgKiBNSU5VVEVfVElNRVNUQU1QCgogICAgICByZXR1cm4gbmV3IERhdGUobWF4VGltZVN0YW1wKQogICAgfSwKICAgIGRheXMoKSB7CiAgICAgIGNvbnN0IGRheXMgPSBbXQogICAgICBjb25zdCBkYXlEaWZmID0gZ2V0RGF5RGlmZih0aGlzLm1pblRpbWUsIHRoaXMubm93KQogICAgICBjb25zdCBsZW4gPSB0aGlzLm1heCA/IGdldERheURpZmYodGhpcy5tYXhUaW1lLCB0aGlzLm1pblRpbWUpICsgMSA6IHRoaXMuX2RheS5sZW4KCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSArdGhpcy5taW5UaW1lICsgaSAqIERBWV9USU1FU1RBTVAKICAgICAgICBkYXlzLnB1c2goewogICAgICAgICAgdmFsdWU6IHRpbWVzdGFtcCwKICAgICAgICAgIHRleHQ6ICh0aGlzLl9kYXkuZmlsdGVyICYmIHRoaXMuX2RheS5maWx0ZXJbZGF5RGlmZiArIGldKSB8fCBmb3JtYXREYXRlKG5ldyBEYXRlKHRpbWVzdGFtcCksIHRoaXMuX2RheS5mb3JtYXQpCiAgICAgICAgfSkKICAgICAgfQogICAgICByZXR1cm4gZGF5cwogICAgfSwKICAgIGhvdXJzKCkgewogICAgICBjb25zdCBob3VycyA9IFtdCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjQ7IGkrKykgewogICAgICAgIGhvdXJzLnB1c2goewogICAgICAgICAgdmFsdWU6IGksCiAgICAgICAgICB0ZXh0OiBgJHtpfSR7dGhpcy4kdCgnaG91cnMnKX1gLAogICAgICAgICAgY2hpbGRyZW46IHRoaXMubWludXRlcwogICAgICAgIH0pCiAgICAgIH0KICAgICAgcmV0dXJuIGhvdXJzCiAgICB9LAogICAgbWludXRlcygpIHsKICAgICAgY29uc3QgbWludXRlcyA9IFtdCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjA7IGkgKz0gdGhpcy5taW51dGVTdGVwTnVtYmVyKSB7CiAgICAgICAgbWludXRlcy5wdXNoKHsKICAgICAgICAgIHZhbHVlOiBpLAogICAgICAgICAgdGV4dDogYCR7cGFkKGkpfSR7dGhpcy4kdCgnbWludXRlcycpfWAKICAgICAgICB9KQogICAgICB9CiAgICAgIHJldHVybiBtaW51dGVzCiAgICB9LAogICAgY2FzY2FkZURhdGEoKSB7CiAgICAgIGNvbnN0IGRheXMgPSB0aGlzLmRheXMuc2xpY2UoKQoKICAgICAgLy8gV2hlbiB0aGUgbWF4VGltZSBpcyBzbWFsbGVyIHRoYW4gbWluVGltZSBieSBtb3JlIHRoYW4gYSBtaW51dGUgc3RlcCwgdGhlcmUgaXMgbm8gb3B0aW9uIGNvdWxkIGJlIGNob3Nlbi4KICAgICAgaWYgKHRoaXMubWF4VGltZSAtIHRoaXMubWluVGltZSA8PSAtNjAwMDApIHsKICAgICAgICB3YXJuKCdUaGUgbWF4IGlzIHNtYWxsZXIgdGhhbiB0aGUgbWluIG9wdGlvbmFsIHRpbWUuJywgQ09NUE9ORU5UX05BTUUpCiAgICAgICAgcmV0dXJuIFtdCiAgICAgIH0KCiAgICAgIGRheXMuZm9yRWFjaCgoZGF5LCBpbmRleCkgPT4gewogICAgICAgIGNvbnN0IGlzTWluRGF5ID0gaW5kZXggPT09IDAKICAgICAgICBjb25zdCBpc01heERheSA9IGluZGV4ID09PSBkYXlzLmxlbmd0aCAtIDEKCiAgICAgICAgaWYgKCFpc01pbkRheSAmJiAhaXNNYXhEYXkpIHsKICAgICAgICAgIGRheS5jaGlsZHJlbiA9IHRoaXMuaG91cnMKICAgICAgICAgIHJldHVybgogICAgICAgIH0KCiAgICAgICAgY29uc3QgcGFydEhvdXJzID0gW10KICAgICAgICBjb25zdCBtaW5Ib3VyID0gaXNNaW5EYXkgPyB0aGlzLm1pblRpbWUuZ2V0SG91cnMoKSA6IDAKICAgICAgICBjb25zdCBtYXhIb3VyID0gaXNNYXhEYXkgPyB0aGlzLm1heFRpbWUuZ2V0SG91cnMoKSA6IDIzCgogICAgICAgIGZvciAobGV0IGkgPSBtaW5Ib3VyOyBpIDw9IG1heEhvdXI7IGkrKykgewogICAgICAgICAgY29uc3QgaXNNaW5Ib3VyID0gaXNNaW5EYXkgJiYgaSA9PT0gbWluSG91cgogICAgICAgICAgY29uc3QgaXNNYXhIb3VyID0gaXNNYXhEYXkgJiYgaSA9PT0gbWF4SG91cgoKICAgICAgICAgIGlmICghaXNNaW5Ib3VyICYmICFpc01heEhvdXIpIHsKICAgICAgICAgICAgcGFydEhvdXJzLnB1c2goewogICAgICAgICAgICAgIHZhbHVlOiBpLAogICAgICAgICAgICAgIHRleHQ6IGAke2l9JHt0aGlzLiR0KCdob3VycycpfWAsCiAgICAgICAgICAgICAgY2hpbGRyZW46IHRoaXMubWludXRlcwogICAgICAgICAgICB9KQogICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgfQoKICAgICAgICAgIC8vIE1hdGgucm91bmQgaXMgdXNlIHRvIGF2b2lkIHNvbWUgd2VpcmQgZmxvYXQgYnVnIG9mIG11bHRpcGxpY2F0aW9uIGFuZCBkaXZpc2lvbmx1YXRlIGluIEphdmFTY3JpcHQuIEJlY2F1c2Ugd2UgaGF2ZSB0byBlbnN1cmUgdGhlIGFyZ3VtZW50cyBvZiBBcnJheS5zbGljZSBhcmUgaW50LgogICAgICAgICAgY29uc3Qgc3RhcnQgPSBpc01pbkhvdXIgPyBNYXRoLnJvdW5kKHRoaXMubWluVGltZS5nZXRNaW51dGVzKCkgLyB0aGlzLm1pbnV0ZVN0ZXBOdW1iZXIpIDogMAogICAgICAgICAgY29uc3QgZW5kID0gaXNNYXhIb3VyID8gTWF0aC5yb3VuZCh0aGlzLm1heFRpbWUuZ2V0TWludXRlcygpIC8gdGhpcy5taW51dGVTdGVwTnVtYmVyKSA6IE1hdGguZmxvb3IoNTkgLyB0aGlzLm1pbnV0ZVN0ZXBOdW1iZXIpCgogICAgICAgICAgY29uc3QgcGFydE1pbnV0ZXMgPSB0aGlzLm1pbnV0ZXMuc2xpY2Uoc3RhcnQsIGVuZCArIDEpCiAgICAgICAgICBwYXJ0SG91cnMucHVzaCh7CiAgICAgICAgICAgIHZhbHVlOiBpLAogICAgICAgICAgICB0ZXh0OiBgJHtpfSR7dGhpcy4kdCgnaG91cnMnKX1gLAogICAgICAgICAgICBjaGlsZHJlbjogcGFydE1pbnV0ZXMKICAgICAgICAgIH0pCiAgICAgICAgfQoKICAgICAgICBkYXkuY2hpbGRyZW4gPSBwYXJ0SG91cnMKICAgICAgfSkKCiAgICAgIGlmICh0aGlzLnNob3dOb3cpIHsKICAgICAgICBkYXlzWzBdLmNoaWxkcmVuLnVuc2hpZnQoewogICAgICAgICAgdmFsdWU6IE5PVy52YWx1ZSwKICAgICAgICAgIHRleHQ6IHRoaXMubm93VGV4dCwKICAgICAgICAgIGNoaWxkcmVuOiBbXQogICAgICAgIH0pCiAgICAgIH0KCiAgICAgIHJldHVybiBkYXlzCiAgICB9CiAgfSwKICBtZXRob2RzOiB7CiAgICBzaG93KCkgewogICAgICBpZiAodGhpcy5pc1Zpc2libGUpIHsKICAgICAgICByZXR1cm4KICAgICAgfQogICAgICB0aGlzLmlzVmlzaWJsZSA9IHRydWUKCiAgICAgIHRoaXMuX3VwZGF0ZU5vdygpCiAgICAgIHRoaXMuX3VwZGF0ZVNlbGVjdGVkSW5kZXgoKQogICAgfSwKICAgIHNldFRpbWUodmFsdWUpIHsKICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlCgogICAgICB0aGlzLmlzVmlzaWJsZSAmJiB0aGlzLl91cGRhdGVTZWxlY3RlZEluZGV4KCkKICAgIH0sCiAgICBfdXBkYXRlU2VsZWN0ZWRJbmRleCgpIHsKICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlCiAgICAgIGNvbnN0IG1pblRpbWUgPSB0aGlzLm1pblRpbWUKICAgICAgLy8gZml4IHRoZSB2YWx1ZSBsYXN0IGNob29zZSB3YXMgY2hhbmdlZCB3aGVuIHRpbWUtcGlja2VyIGlzIG9wZW5lZCBhZ2FpbgogICAgICBjb25zdCBjb21wYXJhdGl2ZVRpbWUgPSAodGhpcy5taW4gfHwgdGhpcy5taW4gPT09IDApCiAgICAgICAgPyArbWluVGltZQogICAgICAgIDogTWF0aC5mbG9vcihtaW5UaW1lIC8gTUlOVVRFX1RJTUVTVEFNUCkgKiBNSU5VVEVfVElNRVNUQU1QCiAgICAgIGlmICh2YWx1ZSA8IGNvbXBhcmF0aXZlVGltZSkgewogICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IFswLCAwLCAwXQogICAgICB9IGVsc2UgewogICAgICAgIC8vIGNhbGN1bGF0ZSBkYXlJbmRleAogICAgICAgIGNvbnN0IHZhbHVlRGF0ZSA9IG5ldyBEYXRlKHZhbHVlKQogICAgICAgIGNvbnN0IGRheUluZGV4ID0gZ2V0RGF5RGlmZih2YWx1ZURhdGUsIG1pblRpbWUpCgogICAgICAgIGlmIChkYXlJbmRleCA+PSB0aGlzLmRheXMubGVuZ3RoKSB7CiAgICAgICAgICB3YXJuKCdVc2UgInNldFRpbWUiIHRvIHNldCBhIHRpbWUgZXhjZWVkZWQgdG8gdGhlIG9wdGlvbiByYW5nZSBkbyBub3QgYWN0dWFsbHkgd29yay4nLCBDT01QT05FTlRfTkFNRSkKICAgICAgICAgIHJldHVybgogICAgICAgIH0KCiAgICAgICAgLy8gY2FsY3VsYXRlIGhvdXJJbmRleAogICAgICAgIGNvbnN0IGhvdXIgPSB2YWx1ZURhdGUuZ2V0SG91cnMoKQogICAgICAgIGNvbnN0IGJlZ2luSG91ciA9IGRheUluZGV4ID09PSAwCiAgICAgICAgICA/IHRoaXMuc2hvd05vdwogICAgICAgICAgICA/IHRoaXMubWluVGltZS5nZXRIb3VycygpIC0gMQogICAgICAgICAgICA6IHRoaXMubWluVGltZS5nZXRIb3VycygpCiAgICAgICAgICA6IDAKICAgICAgICBjb25zdCBob3VySW5kZXggPSBob3VyIC0gYmVnaW5Ib3VyCgogICAgICAgIC8vIGNhbGN1bGF0ZSBtaW51dGVJbmRleAogICAgICAgIGNvbnN0IG1pbnV0ZSA9IHRoaXMubWludXRlU3RlcFJ1bGUodmFsdWVEYXRlLmdldE1pbnV0ZXMoKSAvIHRoaXMubWludXRlU3RlcE51bWJlcikKICAgICAgICBjb25zdCBiZWdpbk1pbnV0ZSA9ICFkYXlJbmRleCAmJiAodGhpcy5zaG93Tm93ID8gaG91ckluZGV4ID09PSAxIDogIWhvdXJJbmRleCkKICAgICAgICAgID8gdGhpcy5taW51dGVTdGVwUnVsZSh0aGlzLm1pblRpbWUuZ2V0TWludXRlcygpIC8gdGhpcy5taW51dGVTdGVwTnVtYmVyKQogICAgICAgICAgOiAwCiAgICAgICAgY29uc3QgbWludXRlSW5kZXggPSBtaW51dGUgLSBiZWdpbk1pbnV0ZQoKICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSBbZGF5SW5kZXgsIGhvdXJJbmRleCwgbWludXRlSW5kZXhdCiAgICAgIH0KICAgIH0sCiAgICBfdXBkYXRlTm93KCkgewogICAgICB0aGlzLm5vdyA9IG5ldyBEYXRlKCkKICAgIH0sCiAgICBfcGlja2VyQ2hhbmdlKGksIG5ld0luZGV4KSB7CiAgICAgIHRoaXMuJGVtaXQoRVZFTlRfQ0hBTkdFLCBpLCBuZXdJbmRleCkKICAgIH0sCiAgICBfcGlja2VyU2VsZWN0KHNlbGVjdGVkVmFsLCBzZWxlY3RlZEluZGV4LCBzZWxlY3RlZFRleHQpIHsKICAgICAgbGV0IHRpbWVzdGFtcAogICAgICBsZXQgdGV4dAogICAgICBpZiAoc2VsZWN0ZWRWYWxbMV0gPT09IE5PVy52YWx1ZSkgewogICAgICAgIHRpbWVzdGFtcCA9ICtuZXcgRGF0ZSgpCiAgICAgICAgdGV4dCA9IHRoaXMubm93VGV4dAogICAgICB9IGVsc2UgewogICAgICAgIHRpbWVzdGFtcCA9IGdldFplcm9TdGFtcChuZXcgRGF0ZShzZWxlY3RlZFZhbFswXSkpICsgc2VsZWN0ZWRWYWxbMV0gKiBIT1VSX1RJTUVTVEFNUCArIHNlbGVjdGVkVmFsWzJdICogTUlOVVRFX1RJTUVTVEFNUAogICAgICAgIHRleHQgPSBzZWxlY3RlZFRleHRbMF0gKyAnICcgKyBzZWxlY3RlZFRleHRbMV0gKyAnOicgKyBzZWxlY3RlZFRleHRbMl0KICAgICAgfQoKICAgICAgdGhpcy52YWx1ZSA9IHRpbWVzdGFtcAogICAgICBjb25zdCBmb3JtYXRlZFRpbWUgPSBmb3JtYXREYXRlKG5ldyBEYXRlKHRpbWVzdGFtcCksIHRoaXMuZm9ybWF0KQogICAgICB0aGlzLiRlbWl0KEVWRU5UX1NFTEVDVCwgdGltZXN0YW1wLCB0ZXh0LCBmb3JtYXRlZFRpbWUpCiAgICB9LAogICAgX3BpY2tlckNhbmNlbCgpIHsKICAgICAgdGhpcy4kZW1pdChFVkVOVF9DQU5DRUwpCiAgICB9CiAgfQp9Cg=="},{"version":3,"sources":["time-picker.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"time-picker.vue","sourceRoot":"node_modules/cube-ui/src/components/time-picker","sourcesContent":["<template>\n  <cube-cascade-picker\n    ref=\"picker\"\n    v-model=\"isVisible\"\n    :data=\"cascadeData\"\n    :selected-index=\"selectedIndex\"\n    :title=\"_title\"\n    :subtitle=\"subtitle\"\n    :cancel-txt=\"_cancelTxt\"\n    :confirm-txt=\"_confirmTxt\"\n    :swipe-time=\"swipeTime\"\n    :z-index=\"zIndex\"\n    :mask-closable=\"maskClosable\"\n    @select=\"_pickerSelect\"\n    @cancel=\"_pickerCancel\"\n    @change=\"_pickerChange\">\n  </cube-cascade-picker>\n</template>\n\n<script type=\"text/ecmascript-6\">\n  import {\n    pad,\n    formatDate,\n    getZeroStamp,\n    getDayDiff,\n    DAY_TIMESTAMP,\n    HOUR_TIMESTAMP,\n    MINUTE_TIMESTAMP\n  } from '../../common/lang/date'\n  import visibilityMixin from '../../common/mixins/visibility'\n  import popupMixin from '../../common/mixins/popup'\n  import pickerMixin from '../../common/mixins/picker'\n  import localeMixin from '../../common/mixins/locale'\n  import CubeCascadePicker from '../cascade-picker/cascade-picker.vue'\n  import { warn } from '../../common/helpers/debug'\n\n  const COMPONENT_NAME = 'cube-time-picker'\n  const EVENT_SELECT = 'select'\n  const EVENT_CANCEL = 'cancel'\n  const EVENT_CHANGE = 'change'\n\n  const NOW = {\n    value: 'now'\n  }\n\n  const INT_RULE = {\n    floor: 'floor',\n    ceil: 'ceil',\n    round: 'round'\n  }\n\n  const DEFAULT_STEP = 10\n\n  export default {\n    name: COMPONENT_NAME,\n    mixins: [visibilityMixin, popupMixin, pickerMixin, localeMixin],\n    components: {\n      CubeCascadePicker\n    },\n    props: {\n      title: {\n        type: String,\n        default: ''\n      },\n      delay: {\n        type: Number,\n        default: 15\n      },\n      day: {\n        type: Object,\n        default() {\n          return {\n            len: 3\n          }\n        }\n      },\n      showNow: {\n        type: [Boolean, Object],\n        default: true\n      },\n      minuteStep: {\n        type: [Number, Object],\n        default: DEFAULT_STEP\n      },\n      format: {\n        type: String,\n        default: 'YYYY/M/D hh:mm'\n      },\n      min: {\n        type: [Date, Number],\n        default: null\n      },\n      max: {\n        type: [Date, Number],\n        default: null\n      }\n    },\n    data() {\n      return {\n        now: new Date(),\n        selectedIndex: [0, 0, 0],\n        value: 0\n      }\n    },\n    computed: {\n      _title () {\n        return this.title || this.$t('selectTime')\n      },\n      _day () {\n        const defaultDay = {\n          filter: [this.$t('today')],\n          format: this.$t('formatDate')\n        }\n        return Object.assign({}, defaultDay, this.day)\n      },\n      nowText() {\n        const defaultText = this.$t('now')\n        return (this.showNow && this.showNow.text) || defaultText\n      },\n      minuteStepRule() {\n        const minuteStep = this.minuteStep\n        return (typeof minuteStep === 'object' && Math[INT_RULE[minuteStep.rule]]) || Math[INT_RULE.floor]\n      },\n      minuteStepNumber() {\n        const minuteStep = this.minuteStep\n        return typeof minuteStep === 'number' ? minuteStep : (minuteStep.step || DEFAULT_STEP)\n      },\n      minTime() {\n        let minTimeStamp = +this.min || +this.now + this.delay * MINUTE_TIMESTAMP\n\n        // Handle the minTime selectable change caused by minute step.\n        const minute = new Date(minTimeStamp).getMinutes()\n        const intMinute = Math.min(this.minuteStepRule(minute / this.minuteStepNumber) * this.minuteStepNumber, 60)\n\n        minTimeStamp += (intMinute - minute) * MINUTE_TIMESTAMP\n        return new Date(minTimeStamp)\n      },\n      maxTime() {\n        let maxTimeStamp = +this.max || (getZeroStamp(new Date(+this.minTime + this._day.len * DAY_TIMESTAMP)) - 1)\n\n        const minute = new Date(maxTimeStamp).getMinutes()\n        const intMinute = Math.floor(minute / this.minuteStepNumber) * this.minuteStepNumber\n        maxTimeStamp -= (minute - intMinute) * MINUTE_TIMESTAMP\n\n        return new Date(maxTimeStamp)\n      },\n      days() {\n        const days = []\n        const dayDiff = getDayDiff(this.minTime, this.now)\n        const len = this.max ? getDayDiff(this.maxTime, this.minTime) + 1 : this._day.len\n\n        for (let i = 0; i < len; i++) {\n          const timestamp = +this.minTime + i * DAY_TIMESTAMP\n          days.push({\n            value: timestamp,\n            text: (this._day.filter && this._day.filter[dayDiff + i]) || formatDate(new Date(timestamp), this._day.format)\n          })\n        }\n        return days\n      },\n      hours() {\n        const hours = []\n        for (let i = 0; i < 24; i++) {\n          hours.push({\n            value: i,\n            text: `${i}${this.$t('hours')}`,\n            children: this.minutes\n          })\n        }\n        return hours\n      },\n      minutes() {\n        const minutes = []\n        for (let i = 0; i < 60; i += this.minuteStepNumber) {\n          minutes.push({\n            value: i,\n            text: `${pad(i)}${this.$t('minutes')}`\n          })\n        }\n        return minutes\n      },\n      cascadeData() {\n        const days = this.days.slice()\n\n        // When the maxTime is smaller than minTime by more than a minute step, there is no option could be chosen.\n        if (this.maxTime - this.minTime <= -60000) {\n          warn('The max is smaller than the min optional time.', COMPONENT_NAME)\n          return []\n        }\n\n        days.forEach((day, index) => {\n          const isMinDay = index === 0\n          const isMaxDay = index === days.length - 1\n\n          if (!isMinDay && !isMaxDay) {\n            day.children = this.hours\n            return\n          }\n\n          const partHours = []\n          const minHour = isMinDay ? this.minTime.getHours() : 0\n          const maxHour = isMaxDay ? this.maxTime.getHours() : 23\n\n          for (let i = minHour; i <= maxHour; i++) {\n            const isMinHour = isMinDay && i === minHour\n            const isMaxHour = isMaxDay && i === maxHour\n\n            if (!isMinHour && !isMaxHour) {\n              partHours.push({\n                value: i,\n                text: `${i}${this.$t('hours')}`,\n                children: this.minutes\n              })\n              continue\n            }\n\n            // Math.round is use to avoid some weird float bug of multiplication and divisionluate in JavaScript. Because we have to ensure the arguments of Array.slice are int.\n            const start = isMinHour ? Math.round(this.minTime.getMinutes() / this.minuteStepNumber) : 0\n            const end = isMaxHour ? Math.round(this.maxTime.getMinutes() / this.minuteStepNumber) : Math.floor(59 / this.minuteStepNumber)\n\n            const partMinutes = this.minutes.slice(start, end + 1)\n            partHours.push({\n              value: i,\n              text: `${i}${this.$t('hours')}`,\n              children: partMinutes\n            })\n          }\n\n          day.children = partHours\n        })\n\n        if (this.showNow) {\n          days[0].children.unshift({\n            value: NOW.value,\n            text: this.nowText,\n            children: []\n          })\n        }\n\n        return days\n      }\n    },\n    methods: {\n      show() {\n        if (this.isVisible) {\n          return\n        }\n        this.isVisible = true\n\n        this._updateNow()\n        this._updateSelectedIndex()\n      },\n      setTime(value) {\n        this.value = value\n\n        this.isVisible && this._updateSelectedIndex()\n      },\n      _updateSelectedIndex() {\n        const value = this.value\n        const minTime = this.minTime\n        // fix the value last choose was changed when time-picker is opened again\n        const comparativeTime = (this.min || this.min === 0)\n          ? +minTime\n          : Math.floor(minTime / MINUTE_TIMESTAMP) * MINUTE_TIMESTAMP\n        if (value < comparativeTime) {\n          this.selectedIndex = [0, 0, 0]\n        } else {\n          // calculate dayIndex\n          const valueDate = new Date(value)\n          const dayIndex = getDayDiff(valueDate, minTime)\n\n          if (dayIndex >= this.days.length) {\n            warn('Use \"setTime\" to set a time exceeded to the option range do not actually work.', COMPONENT_NAME)\n            return\n          }\n\n          // calculate hourIndex\n          const hour = valueDate.getHours()\n          const beginHour = dayIndex === 0\n            ? this.showNow\n              ? this.minTime.getHours() - 1\n              : this.minTime.getHours()\n            : 0\n          const hourIndex = hour - beginHour\n\n          // calculate minuteIndex\n          const minute = this.minuteStepRule(valueDate.getMinutes() / this.minuteStepNumber)\n          const beginMinute = !dayIndex && (this.showNow ? hourIndex === 1 : !hourIndex)\n            ? this.minuteStepRule(this.minTime.getMinutes() / this.minuteStepNumber)\n            : 0\n          const minuteIndex = minute - beginMinute\n\n          this.selectedIndex = [dayIndex, hourIndex, minuteIndex]\n        }\n      },\n      _updateNow() {\n        this.now = new Date()\n      },\n      _pickerChange(i, newIndex) {\n        this.$emit(EVENT_CHANGE, i, newIndex)\n      },\n      _pickerSelect(selectedVal, selectedIndex, selectedText) {\n        let timestamp\n        let text\n        if (selectedVal[1] === NOW.value) {\n          timestamp = +new Date()\n          text = this.nowText\n        } else {\n          timestamp = getZeroStamp(new Date(selectedVal[0])) + selectedVal[1] * HOUR_TIMESTAMP + selectedVal[2] * MINUTE_TIMESTAMP\n          text = selectedText[0] + ' ' + selectedText[1] + ':' + selectedText[2]\n        }\n\n        this.value = timestamp\n        const formatedTime = formatDate(new Date(timestamp), this.format)\n        this.$emit(EVENT_SELECT, timestamp, text, formatedTime)\n      },\n      _pickerCancel() {\n        this.$emit(EVENT_CANCEL)\n      }\n    }\n  }\n</script>\n"]}]}